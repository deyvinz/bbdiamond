import { NextRequest, NextResponse } from 'next/server'
import { supabaseServer } from '@/lib/supabase-server'
import { sendInviteEmail } from '@/lib/invitations-service'

export async function POST(request: NextRequest) {
  try {
    const supabase = await supabaseServer()
    const { data: { user } } = await supabase.auth.getUser()

    if (!user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    const { data: profile } = await supabase
      .from('profiles')
      .select('role')
      .eq('id', user.id)
      .single()

    if (profile?.role !== 'admin' && profile?.role !== 'staff') {
      return NextResponse.json({ error: 'Unauthorized: Only admin or staff can send bulk invites' }, { status: 403 })
    }

    const body = await request.json()
    const { invitationId, eventIds, ignoreRateLimit = false } = body

    if (!invitationId || !eventIds || !Array.isArray(eventIds)) {
      return NextResponse.json({ error: 'Invalid request: invitationId and eventIds are required' }, { status: 400 })
    }

    // Get invitation details
    const { data: invitation, error: invitationError } = await supabase
      .from('invitations')
      .select(`
        *,
        guest:guests(email, first_name, last_name, invite_code),
        invitation_events(
          *,
          event:events(name, starts_at, venue, address)
        )
      `)
      .eq('id', invitationId)
      .single()

    if (invitationError || !invitation) {
      return NextResponse.json({ error: 'Invitation not found' }, { status: 404 })
    }

    // Determine which event to use
    const selectedEvents = invitation.invitation_events?.filter((ie: any) => 
      eventIds.includes(ie.event_id)
    ) || []
    
    if (selectedEvents.length === 0) {
      return NextResponse.json({ error: 'No valid events found for invitation' }, { status: 400 })
    }

    // Skip rate limit check if ignoreRateLimit is true
    if (!ignoreRateLimit) {
      // Check rate limit
      const today = new Date().toISOString().split('T')[0]
      const { data: mailLogs } = await supabase
        .from('mail_logs')
        .select('*')
        .eq('token', invitation.token)
        .gte('sent_at', `${today}T00:00:00.000Z`)

      if (mailLogs && mailLogs.length >= 3) {
        return NextResponse.json({ error: 'Daily email limit exceeded for this invitation' }, { status: 429 })
      }
    }

    // Prepare email data
    const guestName = `${invitation.guest.first_name} ${invitation.guest.last_name}`
    
    // For multiple events, use the first event for the main subject and RSVP URL
    const primaryEvent = selectedEvents[0]
    // Parse text field: "2024-10-16 10:00:00" -> "Wednesday, October 16, 2024 · 10:00"
    const [datePart, timePart] = primaryEvent.event.starts_at.split(' ')
    const [year, month, day] = datePart.split('-')
    const eventDate = new Date(parseInt(year), parseInt(month) - 1, parseInt(day)).toLocaleDateString('en-US', {
      weekday: 'long',
      year: 'numeric',
      month: 'long',
      day: 'numeric',
    })
    const eventTime = timePart ? timePart.substring(0, 5) : '00:00' // Extract HH:MM
    const formattedEventDate = `${eventDate} · ${eventTime}`

    // Generate RSVP URL
    const baseUrl = process.env.NEXT_PUBLIC_APP_URL || 'https://brendabagsherdiamond.com'
    const rsvpUrl = `${baseUrl}/rsvp?token=${invitation.token}`

    // Generate QR code URL
    const qrImageUrl = `${baseUrl}/api/qr?token=${invitation.token}`

    // Generate ICS attachment
    const icsContent = generateIcsAttachment({
      eventName: primaryEvent.event.name,
      startsAt: primaryEvent.event.starts_at,
      venue: primaryEvent.event.venue,
      address: primaryEvent.event.address,
      rsvpUrl
    })

    // Call edge function with new payload
    const { data, error } = await supabase.functions.invoke('send-qr-email', {
      body: {
        to: invitation.guest.email,
        subject: `You're Invited, ${invitation.guest.first_name} — ${selectedEvents.length > 1 ? `${selectedEvents.length} Events` : primaryEvent.event.name}`,
        html: '', // Will be generated by edge function
        text: '', // Will be generated by edge function
        meta: {
          invitationId: invitationId,
          eventIds: eventIds,
          rsvpUrl,
          guestName,
          inviteCode: invitation.guest.invite_code,
          events: selectedEvents.map((event: any) => ({
            id: event.event_id,
            name: event.event.name,
            startsAtISO: event.event.starts_at,
            venue: event.event.venue,
            address: event.event.address,
          })),
          primaryEvent: {
            id: primaryEvent.event_id,
            name: primaryEvent.event.name,
            startsAtISO: primaryEvent.event.starts_at,
            venue: primaryEvent.event.venue,
            address: primaryEvent.event.address,
          },
          includeQr: true,
          eventDate: formattedEventDate,
          qrImageUrl,
        },
        attachments: [
          {
            filename: 'event.ics',
            content: icsContent,
            contentType: 'text/calendar',
          },
        ],
      }
    })

    // Log mail attempt
    await supabase
      .from('mail_logs')
      .insert({
        token: invitation.token,
        email: invitation.guest.email,
        sent_at: new Date().toISOString(),
        success: !error,
        error_message: error?.message
      })

    if (error) {
      return NextResponse.json({ error: `Failed to send email: ${error.message}` }, { status: 500 })
    }

    return NextResponse.json({ success: true, message: 'Email sent successfully' })

  } catch (error) {
    console.error('Send bulk invite error:', error)
    return NextResponse.json(
      { error: 'Failed to send bulk invite' },
      { status: 500 }
    )
  }
}

function generateIcsAttachment({
  eventName,
  startsAt,
  venue,
  address,
  rsvpUrl,
}: {
  eventName: string
  startsAt: string
  venue: string
  address?: string
  rsvpUrl: string
}): string {
  // Format for iCal - convert text field to iCal format for all-day events
  const formatDate = (dateString: string) => {
    // Convert "2024-10-16 10:00:00" to "20241016" (date only for all-day events)
    if (!dateString) return '20240101' // Default fallback
    
    const [datePart] = dateString.split(' ')
    if (!datePart) return '20240101' // Safety check
    
    return datePart.replace(/-/g, '') // "2024-10-16" -> "20241016"
  }

  // Calculate next day for DTEND (all-day events end on the next day)
  const getNextDay = (dateString: string) => {
    if (!dateString) return '20240102' // Default fallback
    
    const [datePart] = dateString.split(' ')
    if (!datePart) return '20240102' // Safety check
    
    const [year, month, day] = datePart.split('-').map(Number)
    const nextDay = new Date(year, month - 1, day + 1)
    return `${nextDay.getFullYear()}${String(nextDay.getMonth() + 1).padStart(2, '0')}${String(nextDay.getDate()).padStart(2, '0')}`
  }

  const location = address ? `${venue}, ${address}` : venue
  
  // Generate unique UID based on event name and start time
  const eventId = Buffer.from(`${eventName}-${startsAt}`).toString('base64').replace(/[^a-zA-Z0-9]/g, '')

  const ics = [
    'BEGIN:VCALENDAR',
    'VERSION:2.0',
    'PRODID:-//Brenda & Diamond//Wedding//EN',
    'BEGIN:VEVENT',
    `UID:${eventId}@brendabagsherdiamond.com`,
    `DTSTAMP:${formatDate(new Date().toISOString().replace('T', ' ').substring(0, 19))}`,
    `DTSTART;VALUE=DATE:${formatDate(startsAt)}`,
    `DTEND;VALUE=DATE:${getNextDay(startsAt)}`,
    `SUMMARY:${eventName}`,
    `LOCATION:${location}`,
    `URL:${rsvpUrl}`,
    'END:VEVENT',
    'END:VCALENDAR'
  ].join('\r\n')

  return Buffer.from(ics).toString('base64')
}
